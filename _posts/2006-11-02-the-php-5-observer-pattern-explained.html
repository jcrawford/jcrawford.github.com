--- 
status: publish
meta: 
  views: "655"
  _bitly_trim: http://www.josephcrawford.com/?p=169
type: post
layout: post
title: The PHP 5 Observer Pattern Explained
published: true
tags: 
- Development
- Raves
---
<p>We are going to discuss the Observer pattern, this pattern is what you will use when you have several objects that need to react when an event from another object is triggered.  Please ignore the echo statements that are scattered around the code, they are there because they show the flow process of the code when run in the browser.</p><p>When using the Observer pattern you will need to create 2 interfaces.  The Observable and Observer interface.  These are pretty well self explanatory by the names.  As you would guess the Observer interface is what you implement on objects that will observe another object.</p><p>[php]interface Observable {<br />function attach( Observer $observer );<br />function detach( Observer $observer );<br />function notify( );<br />} [/php]</p><p>The Observable interface is a pretty simple concept.  It is also pretty well self explanatory, it contains 3 methods attach, detach and notify.  The attach and detach methods require a parameter be passed into them.  It also uses type casting to enforce that they implement the Observer interface.  You would not want to attach an object to the Observable object that does not implement the Observer Interface.  It could lack the required method and could cause bugs in your code.</p><p>The Observer interface requires any objects that implement it to contain only 1 method.  The update method.  This method is passed the Observable object as a parameter and therefore we have used type casting again to enforce the object passed in implement the Observable interface.</p><p>[php]<br />interface Observer<br />{<br />function update( Observable $observer );<br />}<br />[/php]</p><p>Now that we have the interfaces out of the way we need to create the object that will be Observable.  I have chosen to name the class Order.  Whenever the processOrder method is called it in turn calls the notify method.  The notify method will loop over all of the observer objects and call their update methods.  It passes the instance of the Order class to the Observer object so that it can access the object.  In this example we are just accessing the status of the Order object.</p><!--more--><p>[php]<br />class Order implements Observable<br />{<br />private $observers = array( );<br />private $status = array( );<br />private $items = array( );</p><p>function __construct( )<br />{<br />echo 'In Order Constructor!';<br />}<br />function Order( )<br />{</p><p>}</p><p>function attach( Observer $observer )<br />{<br />echo 'Attaching '.get_class($observer).' to Order!';<br />$this-&gt;observers[] = $observer;<br />}</p><p>function detach( Observer $observer )<br />{<br />$this-&gt;observers = array_diff( $this-&gt;observers, array( $observer ) );<br />}</p><p>function notify( )<br />{<br />foreach ( $this-&gt;observers as $obs )<br />{<br />echo 'Notifying '.get_class($this).'!';<br />$obs-&gt;update( $this );<br />}<br />}</p><p>function processOrder( )<br />{<br />// notify the observers<br />echo 'Processing Order!';<br />$this-&gt;setStatus('Processing Order');<br />$this-&gt;notify( );<br />}</p><p>function setStatus( $status )<br />{<br />$this-&gt;status = array( $status );<br />}</p><p>function getStatus( )<br />{<br />return $this-&gt;status;<br />}<br />}<br />[/php]</p><p>Ok so all that is left is the object that will implement the Observer interface.  I have chosen to use something that a lot of sites implement.  A logging class.</p><p>[php]<br />class GeneralLogger implements Observer<br />{<br />function __construct()<br />{<br />echo 'Creating '.get_class($this).'!';<br />}<br />function GeneralLogger()<br />{<br />$this-&gt;__construct();<br />}</p><p>function update( Observable $observer )<br />{<br />$status = $observer-&gt;getStatus( );<br />echo 'Logging: '.$status[0].'!';<br />}<br />}<br />[/php]</p><p>This class implements the Observer interface and implements the required update method.  In this method all we do is retrieve the status of the Order object that is passed into this object.  We could however do much more if we choose to.</p><p>Now we need to actually setup the objects to work with each other.<br />[php]<br />include_once('includes/interfaces/Observable.php');<br />include_once('includes/interfaces/Observer.php');<br />include_once('includes/classes/Order.php');<br />include_once('includes/classes/GeneralLogger.php');</p><p>$order = new Order( );<br />$order-&gt;attach( new GeneralLogger( ) );<br />$order-&gt;processOrder( );<br />[/php]</p><p>The following output is what you get if you run this script in your browser</p><p>In Order Constructor!<br />Attaching GeneralLogger to Order!<br />Processing Order!<br />Notifying Order!<br />Logging: Processing Order!</p><p>Notice that when we call the processing order, it calls the notifying order method, which in turn calls the logging update method to output the final line in the browser.</p><p>Now you can get quite complex when using the observer pattern, for instance imagine we had a paypal payment module, which implemented both Observable and Observer interfaces (Yes you can do that).  It would be notified upon the execution of processOrder, this would run the update method.  Well maybe we want to start to process the payment at this point.  So we reach out and do the payment stuff, we can now have the payment module alert any of it's personal observers about the results of the payment process.  It payment fails we can have emails sent to the customer and administrator for instance.</p><p>There are quite a few reasons to use the Observer pattern, however just like all patterns you should not use them too much.</p><p>If you have any questions about this small example please feel free to ask in comments, I am always willing to explain the code better so that people can understand it.</p>
